## 并发编程基础 ##

--------------------------
> 思想： 使得多个任务在同一个时间段内执行以便能够更快地得到结果。

* 串行程序与并发程序
    * 串行程序特指只能被顺序执行的指令列表
        * 并发程序则是可以被并发执行的两个及以上的串行程序的综合体。
    * 并发程序与并行程序
        * 并发程序是指可以被同时发起执行的程序，并行程序则是被设计成可以在并行的硬件上执行的并发程序。
    * 并发程序内部的交互
        * 同步，同步的作用是避免在并发访问共享资源是可能发生的冲突，以确保有条不紊的传递数据。
        * 根据同步原则，在用一时刻，某个资源应该只被一个程序占用。
        * 传递数据是并发程序内部的另一种交互方式，也称为并发程序内部的通信。用异步的方式对通信进行管理，这种方式使得数据可以不加延迟地发送给数据接收方。

### 多进程编程 ###

* `IPC` (进程间的通信)
    * 基本通信的 `IPC` 方法
        * 以数据传输为手段
            * 管道(`Pipeline`): 可以用来传输字节流。
            * 消息队列(`Message Queue`): 可以用来传输结构化的消息对象。
            * 以共享内存为手段(最快的一种IPC方法)
        * 基于信号的 `IPC` 方法：操作系统 `signal` 机制，是唯一的一种异步 `IPC` 方法。
        * 基于同步的 `IPC` 方法：信号量 (`simaphone`)
        * `Go` 支持的 `IPC` 方法有： 管道、信号和 `socket`.
    * 进程
        * 定义
            * 进程是操作系统进行**资源分配**的最小基本单位。
        * 进程的衍生
            * 进程使用 `fork` (一个系统调用)可以创建若干个新的进程，其中前者称为父进程，后者称为子进程。
            * 每个子进程都是其父进程的一个副本，它会获得父进程的数据段、堆、栈的副本，并与父进程共享代码段。
            * 每个副本都是独立的
        * 进程的标识 (`PID`)
            * 保存在进程描述符中的进程 `ID` 常称为(`PID`)是进程在操作系统中的唯一标识。
            * `PID` 并不传递与进程有关的任何信息，它只是一个用来唯一标识进程的数字而已；
            * `Go` 标准库代码包 `os` 可以查看 `PID` 和 `PPID`

			```go
				pid := os.Getpid()
				ppid := os.Getppid()
			```

    * 进程的状态
        * **可运行状态** (`TASK_RUNNING`). 处改状态的进程是立刻要或者正在CPU上运行。不过运行的 时机不确定，这个由进程调度器来决定。
        * **可中断的睡眠状态** (`TASK_INTERRUPT`). 当进程正在等待某个事件(比如网路连接或信号量)到来时，会进入此状态。
        * **不可中断的睡眠状态** (`TASK_UNINTERRUPT`). 此种状态的进程不会对任何 信号 作出反应。
        * **暂停状态或者跟踪状态** (`TASK_STOPPED` 或 `TASK_TRACED`). 向进程发送 `SIGSTOP` 信号，就会使得该进程转入暂停状态，除非该进程正处于不可中断的睡眠状态。
        * **僵尸状态** (`TASK_DEAD-EXIT_ZOMBIE`). 处于此状态的进程即将结束 运行，该进程占用的绝大多数资源也都已经被回收。
        * **退出状态** (TASK_DEAD-EXIT_DEAD). 
          ![linux操作系统进程的转态转换](03-1-Linux操作系统进程的状态转换.png)
        * **进程的空间**
            * 存在于用户空间中的进程是用户进程，它可以完成很多任务但是不能与计算机硬件进行交互，内核可以与计算机硬件交互，但是其存在于内核空间。用户进程无法直接访问内核空间。
            * 内存区域中每一个单元都是有地址的，这些地址由指针来标识和定位。通过指针来寻找内存单元的操作称作内存寻址。这里的地址并非物理内存中的真实地址，而是虚拟地址。
            * 虚拟地址的最大容量与实际可用的物理内存大小没有关系。内核和 `CPU` 负责维护虚拟内存与物理内存之间的映射关系。
            * 内核为每个用户进程分配的是虚拟内存而不是物理内存。每个用户进程分配到的虚拟内存总是在用户空间而内核空间则是留给内核传用。
            * 进程的虚拟内存之间几乎是彼此独立，互不干扰。这是由于它们基本上被映射到了不同的物理内存。
             ![linux操作系统对虚拟内存的划分](03-3-linux操作系统对虚拟内存的划分.png)
            * 内核会把进程的虚拟内存划分为若干页 (`page`), 物理单元的划分由 `CPU` 负责。一个物理内存单元被称为一个页框(`page frame`). 
            * 页框运行共享。进程`A`的页`7`与进程`B`的页`8`共享同一个页框。实际上这就是共享内存(`IPC`)的基础。
            ![进程的虚拟内存和物理内存](03-2-进程的虚拟内存和物理内存.png)
        * **系统调用**
            * 为了使得用户态的进程能够使用操作系统更底层的功能，内核会向外提供一些接口供用户进程使用。用户进程使用这些接口的行为称为系统调用。
            * 系统调用是向内核空间发出一个明确的请求，系统调用会导致内核空间中数据的存储和指令的执行。而普通函数的调用只是定义了如何获取一个既定的服务，只能在用户空间中执行。
            * 系统调用是内核的一部分，而普通函数的调用不是。
            * 内核态和用户态
              > 大部分时间`CPU`处于用户态，只能对用户空间进行访问。当用户发出有个系统调用时，内核会把`CPU`从用户态切换到内核态，而后让`CPU`执行对应的内核函数。当内核函数执行完毕后，内核会把`CPU`从内核态切换回用户态，并把执行结果返回给用户进程。
              > `CPU`在内核态下是有权执行访问内核空间，这就相当于用户进程可以通过系统调用使用内核提供的功能。

            ![系统调用过程的示意图](03-4-系统调用过程的示意图.png)
* 同步
  
    * 竞态条件: 多个进程需要对同一个资源进行读写操作。
    * 原子操作: 执行过程不能被中断的操作。所有的系统调用都属于原子操作。
    * 临界区: 只能被串行访问或执行的某个资源或某段代码段。
  
* 管道
    * 一种半双工的通信方式。只能用于父进程与其子进程以及同祖先的子进程之间的通信。
    * 命名管道
      > 命名管道默认是阻塞式的。只有在对这个命名管道的读操作和写操作都已经就绪之后，数据才开始流转。命名管道任然是单向的。

      ```go
      // linux 创建命名管道 myfifo1
      cc@lab-test-pc1:~$ mkfifo -m 644 myfifo1
      cc@lab-test-pc1:~$ tee dst.log < myfifo1 &
      [1] 18212
      cc@lab-test-pc1:~$ cat src.log > myfifo1
      ```

      > `os.Pipe()` 函数生成的管道在底层是由于系统级别的管道来支持的，所以使用它们的时候要注意操作系统对管道的限制。比如，匿名管道会在管道缓冲区被写满之后使用写数据的进程阻塞，命名管道会在其中一端被就绪前阻塞另一端的进程。

      ```go
      // Go 标准库代码包 os 中实现了这种独立管道的 API
      // reader表示输出端的*os.File类型的值
      // writer表示输入端的*os.File类型的值
      // err 表示肯能的错误，默认值为nil
      reader, writer, err := os.Pipe()
      ```

      > 命名管道可以被多路复用。也就是说，当有多个输入端同时写入数据的时候，需要考虑操作原子性的问题。操作系统本身提供的管道是不支持原子性操作的，`Go` 标准库代码包 `io` 中提供了一个基于内存的有原子性操作保证的管道(即:**内存管道**)

      ```go
      // 返回值reader代表改管道输出端的*io.PipeReader,只使用Read方法从管道中读取数据
      // 返回值writer代表改管道输入端的*io.PipeWriter,只使用Write方法向管道写入数据
      // 在使用Close()方法关闭管道某一端后，另一端写数据或读数据会得到一个预定义的error类型值
      reader, writer := io.Pipe()
      ```

* 信号(`Signal`)
  
    * `IPC` 中唯一一种通过异步通信的方法。其本质是用软件来模拟硬件的中断机制，信号用来通知某个进程有某个事件发生了。
  
        ```go
        // os.Signal
        type Signal interface {
          String() string
          Signal() // to distinguish from other stringers
        }
        ```

      * `os/signal`中的`Notify`函数用来当操作系统向当前进程发送指定信号事发出通知。

        ```go
        // 第一个参数是通道类型; chan<- os.Signal 表示参数c是一个发送通道,只能向它发送os.Signal类型的值，而不能从中接收信号值。
        // 第二个参数是一个可变长参数。
        func Notify(c chan<- os.Signal, sig ...os.Signal)

        // example
        sigRecv := make(chan os.Signal, 1)
        sigs := []os.Signal{syscall.SIGINT, syscall.SIGQUIT}
        signal.Notify(sigRecv, sigs...)
        // 只要sigRecv有值，for循环按顺序接收并赋值给变量 sig.否则for语句就被阻塞,并等待新的元素值发送到sigRecv中。
        // 在 sigRecv代表的通道类型关闭后, for 语句会立即退出。
        for sig := range sigRecv {
          fmt.Printf("Receive a signal %s\n", sig)
        }
        ```

    * `socket`
        * 通过网络连接让多个进程建立通信并相互传递数据，这使得通信双方是否位于同一台计算机上变得无关紧要。
        * 操作系统的socket接口

          ```c
          // 改系统调用的功能是创建一个socket实例。
          // 三个参数分别代表通信域、类型、所用协议
          int socket(int domain, int type, int protocol);
          ```

          > 通信域(`AF: address family`):
              - `AF_INET`: `IPv4` 域。地址形式: `IPv4` 地址(`4` 个字节 ) + `Port`(`2`个字节)
              - `AF_INET6`: `IPv6` 域。地址形式: `IPv6` 地址(`16` 个字节 ) + `Port`(`2`个字节)
              - `AF_UNIX`: `Unix` 域。地址形式: 路径名称。
          > 类型的特性:
              - 数据包( `SOCK_DGRAM`,  `SOCK_RAW`):
                > 以数据报为数据形式意味着数据接收方的`socket`接口程序可以意识到数据的边界，并会对他们进行切分，这样就省去了接收方的应用程序寻找数据边界和切分数据的工作量。
              - 数据流( `SOCK_STREAM`, `SOCK_SEQPACKET`):
                > 以字节流为数据形式的数据传输实际上传输的是一个字节接着一个字节的串，可以把它想象成一个很大的字节数组。一般情况下，字节流并不能体现出哪些字节是属于哪个数据包，因此，`socket` 接口程序是无法从中分离出独立的数据包，只能由应用程序自己去完成。`SOCK_SEQPACKET`类型的例外。
        * 系统调用 `socker`  会返回一个 `int` 类型的值，该值是 `socket` 实例唯一标识符的文件描述符。一旦得到改标识符，就可以调用其它系统调用来进行各种相关的操作,比如:绑定和监听端口、发送和接收数据以及关闭 `socket` 等。
        * `socket` 接口与 `TCP/IP`协议栈、操作系统内核的关系
          ![`socket` 接口与 `TCP/IP`协议栈、操作系统内核的关系](03-5-socket接口与tcp_ip协议栈以及操作系统关系.png)
        * `Go` 提供的`socket` 编程 `API` 示例:
          ![socket 通信流程](03-6-socket通信流程.png)
          > 服务端程序功能需求:
              - 需要根据事先约定好的数据边界把接收到的请求数据切分成数据块;
              - 仅接收可以有 `int32` 类型表示的请求数据块。对于不符合要求的数据块，要生成错误信息并返回给客户端程序;
              - 对于每个符合要求的数据块，需要计算他们的立方根、生成结果描述并返回给客户端;
              - 需要鉴别闲置的通信连接并主动关闭它们。鉴别依据:再过去的10s内，没有任何数据经改连接传送到服务端程序。
          > 客户端程序需求:
              - 发送给服务端的每块数据请求都携带约定好的数据边界;
              - 需要根据事先约定好的数据边界把接收到的响应数据切分成 数据块;
              - 在获得所有期望的响应数据后，应该及时关闭连接以节省资源
              - 需要严格限制耗时，从开始向服务端程序发送请求数据到接收到所有期望的响应数据，其耗时都不应该超过5s，否则在报告超时错误之后关闭连接。这实际上是对服务端程序响应时间的监测。

          ```go
          // 服务端程序片段

          // net.Listen 调用后，第一个返回值是net.Listen类型，表示监听器;第二个返回值是一个error类型
          listener, err := net.Listen("tcp", "127.0.0.1:8080")

          // 调头Accept()方法，流程被阻塞.知道有某个客户端程序与当前程序建立TCP连接
          // 第一个返回值代表了当前TCP连接的net.Conn类型值; 第二个返回值依然是一个error类型值
          conn, err := net.Accept()

          //
          ```

          ```go
          // 客户端程序片段

          // Dial()函数用于向指定的网络地址发送连接建立申请
          // 一个是net.Conn类型的值；一个是error类型的值
          // 发送连接请求的一份通常会等待一个超时时间，超过timeout时间后，函数的执行就会结束并返回相应的error类型值。Linux操作系统内核中，这个timeout的值设定为75s.
          conn, err := net.Dial("tcp", "127.0.0.1:8080")

          // DialTimeout() 提供请求超时时间的设置
          conn, err := net.DialTimeout("tcp", "127.0.0.1:8080", 2*time.Second)
          ```

          ```go
          // bufio 中的 API 实现一些较复杂的数据切片
          reader := bufio.NewReader(conn)
          // ReadBytes 接收一个byte类型的参数值，该参数是通信两端协商一致的那个消息边界
          line, err := reader.ReadBytes("\n")
          ```

          ```go
          // Read() 方法从socket的接收缓冲区中读取数据
          // 该方法接收一个[]byte类型的参数，该参数值相当于一个用来存放从连接上接收到的数据的容器，其长度完全由应用程序决定。也就是说传给Read方法应该是一个不包含任何非零元素的切片值。
          // 返回值 n 代表本次操作实际读取到的字节个数，也可以理解为Read方法向参数值b []byte中填充的字节的个数
          Read(b []byte) (n int, err error)

          // socket编程API程序在从socket的接收缓冲区读取数据时发现TCP连接已经被另一端关闭了，会立即返回一个error类型的值。若该值为io.EOF，则意味着在此TCP连接之上再无可读取的数据，也就是说改TCP连接已经无用，可以关闭了。
          var dataBuffer bytes.Buffer
          b := make([]byte, 10)
          for {
            n,err := conn.Read(b)
            if err != nil {
              if err == io.EOF {
                fmt.Println("The connection is closed!")
                conn.Close()
              } else {
                fmt.Printf("Read  Error: %s\n", err)
              }
              break
            }
            dataBuffer.Write(b[:n])
          }
          ```

          ```go
          // Write() 方法用于向socket的发送缓冲区写入数据
          Write(b []byte) (n int, err error)

          // bufio 中实现了一个更加灵活的方法
          // 接收参数是一个io.Writer接口的实现类型
          writer := bufio.NewWriter(conn)
          ```

          ```go
          // Close() 方法
          // 该方法会关闭当前的连接，它不接受任何类型的参数，并返回一个error类型的返回值。
          // 如果调用Close()方法时, Read() 或者 Wirte()还在被调用且没有执行结束，那么他们会立即结束执行并返回非nil错误类型值。
          conn.Close()
          ```

          ```go
          // LocalAddr() 和 RemoteAddr() 都不接受任何参数，并返回一个net.Addr类型的结果；
          // LocalAddr() 返回的结果值表示了本地地址，RemoteAddr() 返回的结果值代表了远程地址；
          conn.LocalAddr().Network()
          conn.RemoteAddr().String()

          // 对于客户端，如果在与服务端程序通信时未指定本地地址，那么下面语句可以得到操作系统内核为该客户端程序分配到网络地址
          con.LocalAddr().String()

          // net.Addr  结构体
          type Addr interface {
              Network() string // name of the network (for example, "tcp", "udp")
              String() string  // string form of address (for example, "192.0.2.1:25", "[2001:db8::1]:80")
          }
          ```

### 多线程编程 ###

* `POSIX` 线程(`Portable Operating System Interface of Unix, Unix的可移植性操作系统接口`)
    * 线程可以看作进程中的控制流。一个进程中至少会包含一个线程，因为一个进程中至少会有一个控制流持续运行。
    * 主线程: 一个线程会随着一个进程的启动而创建，这个线程就被称为该进程的主线程。
    * 一个进程可以包含多个线程，这个线程都是由进程中已存在的线程创建出来的，创建的方法是通过系统通用产生的，也就是通过调用 `pthread_create()` 函数。
    * 线程不能独立于进程独自存在。它的生命周期不可能逾越其所属进程的生命周期。
    * 一个进程中线程都拥有自己的线程栈，用来存储自己的私有数据。这些线程的线程栈都包含在其所属进程的虚拟内存地址空间中。
    * 一个进程中的很多资源都被其所属线程共享: (比如:代码段、数据段、堆、信号处理函数已经进程所持有的文件描述符等)
* 线程的标识
  
    * TID: 线程的ID。 与进程ID不同的是线程ID在系统范围内可以不唯一，但在其所属进程范围内唯一。
    * 线程ID是由操作系统内核分配和维护，应用程序无须过多的的关注。
* 线程的控制
    * 进程之间的创建是存在父子关系的树状结构，但是同一进程中的任意两个线程之间的关系是平等的，它们之间不存在层级间的关系。
    * 任何线程都可以对同一进程中的其它线程进行有限的管理:
      > 创建线程: 任何线程都可以通过调用系统调用 `pthread_create` 来创建新的新的线程。在创建新的线程时，调用线程需要给的新线程将要执行的函数以及传入该函数的参数。由于代表该函数的参数被命名为 `start` ,因此常称为 `start` 函数。 `start` 函数是可以有返回值的，如果新线程创建成功，调用线程就会得到新线程的ID；
      > 终止线程: 线程可以通过多种方式终止同一进程中的其它线程。其中一中方式是调用系统调用 `pthread_cancel`. 该函数的作用是取消给的线程ID所代表的那个线程。
      > 连接已终止的线程: 此操作有系统调用 `pthread_join` 来执行。该函数会一直等待与给定的线程ID对应的那个线程终止，并把该线程执行的 `start` 函数的返回追告知调用线程。如果目标线程已经处于终止状态，那么函数会立即返回。这就像把调用线程放在了目标线程的后面，当目标线程把流程控制权交出时，调用线程会接过流程控制权，继续执行 `pthread_join` 之后的代码块。
      > 分离线程: 将一个线程分离，意味着他不再是一个可连接的线程。而默认情况下，一个线程总是可以被其它线程连接。分离线程的另一个作用是让操作系统内核在目标线程终止时，自动进行清理和销毁的工作。此外，分离操作是不可逆，也就是说无法使一个不可连接的线程变成可连接状态。分离操作由系统调用 `pthread_detach` 来执行，它接受一个代表线程ID的参数。
* 线程的转态
    * `Linux` 线程转态切换示意图
  	![`Linux` 线程转态切换](03-7-Linux内核线程转态转换.png)
          - 前缀`[另]` 表示描述的操作是由当前进程中的其它线程执行的
          - 前缀`[自]`表示描述的操作是由当前线程执行的
          - 前缀`[主]`表示描述的操作是由主线程执行的
          - 左侧没有前缀，则表示操作可以由前进程中的任何线程来执行。
          - 当其它线程调用 `pthread_cancle` 或者 `pthread_join` 函数，以及任一线程调用 `pthread_detach`函数，传递给它们的参数值代表了当前线程的ID。只有这样，它们的执行才会对当前线程起作用。
* 线程的调度
    * 操作系统内核的调度器就是使用若干策略对众多线程在 `CPU` 上的运行就行干涉，以使得操作系统中的各个任务能够有条不紊的运行，同时还要兼顾效率和公平性。从线程的角度来看，调度器是通过协调各个线程的状态来达到调度的目的。

* 线程实现的模型
    * 用户级线程模型
    * 内核级线程模型
    * 两级线程模型
  
    ![Linux 3中线程实现模型](03-8-Linux三种线程模型实现.png)
* 线程的同步
    * 共享程序的一致性: 包含多个线程的程序，多以共享数据作为线程之间传递数据的手段。
    * 临界区: 只能被串行化访问或执行某个资源或者某个代码段。
    * 实施共享数据同步的方法: 互斥了、条件变量。
        * 互斥量:
            * 在同一时刻只允许一个线程处于临界区之类的约束称为互斥(`mutex`)。每个线程在进入临界区之前，都必须先锁定某个对象，只有成功锁定临界区的 线程对象才允许进入，其它都会被阻塞。
            * 互斥了的两种可能状态: 已锁定状态和未锁定状态。互斥量只允许锁定一次，处于已锁定的状态的互斥量不能被再次锁定，否则会报错。
            * 线程离开临界区的时候，必须要对相应的互斥量进行解锁。
            * 对同一个互斥量的锁定与解锁必须是成对的存在。
            * 互斥量也属于共享资源，必须能够被所有相关的线程访问到。因此，代表互斥量的变量或者常量一般不是局部的。
            * 初始化互斥量的操作总是在任何线程真正的使用它之前，经过初始化的互斥量处于未锁定的状态。
              ![互斥量保护下的计数器操作](03-9-互斥量保护下的计数器操作.png)
            * 多个互斥量保护下的不通临界区
                * 互斥量1作用域临界区1，互斥量2作用域临界区2
                * 互斥量1和互斥量2作用域互不重叠，线程在离开临界区时，总会解锁相应互斥量，所以程序不会因为同时使用两个互斥量而死锁。
              ![互斥量保护下的临界区](03-10互斥量保护下的临界区.png)
        * 条件变量
            * 条件变量的作用并不是保证同一时间仅有一个线程访问同一个共享资源，而是对应的共享数据发生变化时，通知其它因此而被阻塞的线程。
* 线程安全性
    * 一个代码块，它可以被多个线程并发执行，且总能得到预期的结果，那么该代码块就是线程安全的；如果代码块中包含了对共享数据的操作，那么这个代码块可能是非线程安全的。但是，如果该代码块中的操作都处于临界区中，那么该代码块就是线程安全的。
    * 可重入函数: 如果一个进程中的所有线程都可以并发的对一个函数进行调用，并且无论他们调用该函数的实际情况如何，该函数都能够产生预期的结果。更通俗的讲，如果多个线程并发的调用该函数，与它们以任意顺序依次调用它所产生的效果总是相同，那么该函数就是一个可重入函数。
    * 任何包含了操作共享数据的代码的函数都可以视为不可重入的函数。
* 并发编程注意事项:
    * **控制临界区的纯度**: 临界区中应该仅包含操作共享数据的代码。尽量不要把无关的操作包含其中，尤其是耗时的`I/O`操作。
    * **控制临界区的粒度**: 粒度过细的临界区会增加底层协调工作发生的次数。
    * **减少临界区中的执行耗时**: 提高临界区中的纯度，可以减少临界区中代码的执行耗时。对于操作共享数据的代码，本身执行起来就很耗时的，分两种情况处理：
    	> 情况一，临界区中包含了对几个共享数据的操作代码。在这种情况下，无论这些操作不同共享数据之间的代码之间是否强关联，都可以把他们拆分到不同的临界区中，并使用不同的同步方法加以保护。

    	> 情况二，临界区中仅包含了操作同一个共享数据的代码。这时你往往不能通过分割临界区的方式来达到节省耗时的目的。因为粒度过细的临界区反而会增加而外的时间开销。正确的做法是可以通过调整业务逻辑或改进算法。

    * **避免长时间的持有互斥量**。在临界区中的代码会等待共享数据的某个状态下，使用条件变量往往会达到较好的效果。

    * **优先使用原子操作而不是互斥量**. 原子操作会直接利用硬件级别的原语来保证操作成功和数据并发安全.
